{"version":3,"file":"index.umd.min.js","sources":["../../src/interface.ts","../../src/errors.ts","../../src/manifest-processors.ts","../../src/module-loader-tool.ts"],"sourcesContent":["export enum ModuleLoadStrategy {\n  BLOCK = 'block',\n  IMMEDIATELY = 'immediately',\n  ON_DEMAND = 'on_demand',\n  LAZY = 'lazy'\n}\n\nexport interface IBaseModuleManifest {\n  name: string;\n  loadStrategy: ModuleLoadStrategy;\n  fileName: string;\n}\n\nexport interface IModuleLoaderEntrypoint<T extends IBaseModuleManifest> {\n  manifestUrl: string;\n  // tslint:disable-next-line\n  flattener?: (manifestObject: any) => Array<T>;\n}\n\nexport type ModuleDependencies = Record<string, object>;\nexport type ModuleUrlFormatter<T extends IBaseModuleManifest> = (manifest: T) => string;\n\nexport type CompiledModuleControls = {\n  start?: () => void;\n  getComponent?: () => React.ComponentClass;\n};\n\nexport type CompiledModule = {\n  exports: {\n    controls: CompiledModuleControls;\n    [key: string]: object;\n  };\n};\n\nexport type TypeMatcher<T> = (manifest: T) => boolean;\nexport type ModulePreprocessor<T> = (manifest: T) => Promise<void>;\nexport type ModulePostprocessor<T> = (manifest: T, module: CompiledModule) => Promise<void>;\n","export class NoDependencyError extends Error {}\n// tslint:disable-next-line\nexport class CompileModuleError extends Error {}\n// tslint:disable-next-line\nexport class CreationModuleError extends Error {}\n// tslint:disable-next-line\nexport class LoadBundleError extends Error {}\n// tslint:disable-next-line\nexport class PostprocessorError extends Error {}\n","import { CompiledModule, IBaseModuleManifest, ModulePostprocessor, ModulePreprocessor, TypeMatcher } from './interface';\n\nexport class ManifestProcessors<TModuleManifest extends IBaseModuleManifest> {\n  private typeMatchers: Record<string, TypeMatcher<TModuleManifest>> = {};\n  private modulePreprocessors: Record<string, ModulePreprocessor<TModuleManifest>> = {};\n  private modulePostprocessors: Record<string, ModulePostprocessor<TModuleManifest>> = {};\n\n  private getModuleTypeByManifest(manifest: TModuleManifest): string | void {\n    for (const typeKey of Object.keys(this.typeMatchers)) {\n      const typeMatcher = this.typeMatchers[typeKey];\n      if (typeMatcher(manifest)) {\n        return typeKey;\n      }\n    }\n    console.warn(`Cant resolve type of service \"${manifest.name}\"`);\n    return;\n  }\n\n  registerManifestType(\n    type: string,\n    typeMatcher: TypeMatcher<TModuleManifest>,\n    modulePreprocessor?: ModulePreprocessor<TModuleManifest>,\n    modulePostprocessor?: ModulePostprocessor<TModuleManifest>\n  ): void {\n    this.typeMatchers[type] = typeMatcher;\n    if (modulePreprocessor) {\n      this.modulePreprocessors[type] = modulePreprocessor;\n    }\n    if (modulePostprocessor) {\n      this.modulePostprocessors[type] = modulePostprocessor;\n    }\n  }\n\n  runPreprocessor(manifest: TModuleManifest): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePreprocessors[type] ? this.modulePreprocessors[type](manifest) : Promise.resolve();\n  }\n\n  runPostprocessor(manifest: TModuleManifest, module: CompiledModule): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePostprocessors[type] ? this.modulePostprocessors[type](manifest, module) : Promise.resolve();\n  }\n}\n","import { CompileModuleError, LoadBundleError, NoDependencyError, PostprocessorError } from './errors';\nimport {\n  CompiledModule,\n  IBaseModuleManifest,\n  IModuleLoaderEntrypoint,\n  ModuleDependencies,\n  ModuleLoadStrategy,\n  ModuleUrlFormatter\n} from './interface';\nimport { ManifestProcessors } from './manifest-processors';\n\nconst InvalidHttpStatusStart = 400;\n\nfunction fetchBundleSource(url: string): Promise<string> {\n  return fetch(url).then((response: Response) => {\n    if (response.status >= InvalidHttpStatusStart) {\n      throw new LoadBundleError(`Cant load bundle, http error ${response.status}`);\n    }\n\n    return response.text();\n  });\n}\n\nfunction compileSource(source: string, dependencies: ModuleDependencies): CompiledModule {\n  // @ts-ignore\n  // tslint:disable-next-line\n  const require = (name: string): any => {\n    const dependency = dependencies[name];\n    if (!dependency) {\n      // В любом случае кинуть ошибку. Может быть конечно, что микросервис просит зависимость,\n      // но не использует её и скомпилируется, однако лучше явно сообщить и по результатам:\n      // а) Выпилить зависимость из микросервиса\n      // б) Внести зависимость в ядро\n      // в) Вкомпилировать зависимость в микросервис\n      throw new NoDependencyError(`Dependency \"${name}\" does not provided by core application`);\n    }\n\n    return dependency;\n  };\n  const exports = {};\n  const module = {\n    exports: {}\n  };\n  try {\n    // tslint:disable-next-line\n    eval(source);\n  } catch (ex) {\n    throw new CompileModuleError(`Cant compile module: ${ex.message}`);\n  }\n\n  return module as CompiledModule;\n}\n\nexport class ModuleLoaderTool<TModuleManifest extends IBaseModuleManifest> {\n  private dependencies: ModuleDependencies = {};\n  private urlFormatter: ModuleUrlFormatter<TModuleManifest>;\n  private entrypoint: IModuleLoaderEntrypoint<TModuleManifest>;\n\n  private manifestProcessors: ManifestProcessors<TModuleManifest> = new ManifestProcessors();\n  private _bundlesList: Array<TModuleManifest>;\n  private bundlesCache: Record<string, CompiledModule> = {};\n  private loadersCache: Record<string, Promise<CompiledModule | void>> = {};\n\n  get bundlesList(): Array<TModuleManifest> {\n    return this._bundlesList;\n  }\n\n  private startupCheck(): void {\n    if (!this.urlFormatter) {\n      throw new Error('urlFormatter is not defined');\n    }\n\n    if (!this.entrypoint) {\n      throw new Error('entrypoint is not defined');\n    }\n  }\n\n  private loadBulkBundles(filterFn: (manifest: TModuleManifest) => boolean): Promise<void> {\n    return Promise.all(\n      this.bundlesList.filter(filterFn).map((manifest: TModuleManifest) => this.loadBundleByManifest(manifest))\n    ).then((compiledBundles: Array<CompiledModule | void>) => {\n      compiledBundles.forEach((compiledBundle: CompiledModule | void) => {\n        const controls = compiledBundle && compiledBundle.exports.controls;\n        if (controls && controls.start) {\n          controls.start();\n        }\n      });\n    });\n  }\n\n  defineDependencies(dependencies: ModuleDependencies): void {\n    this.dependencies = dependencies;\n  }\n\n  defineUrlFormatter(formatter: ModuleUrlFormatter<TModuleManifest>): void {\n    this.urlFormatter = formatter;\n  }\n\n  defineEntrypoint(entrypoint: IModuleLoaderEntrypoint<TModuleManifest>): void {\n    this.entrypoint = entrypoint;\n  }\n\n  defineManifestType(\n    type: string,\n    typeMatcher: (manifest: TModuleManifest) => boolean,\n    modulePreprocessor?: (manifest: TModuleManifest) => Promise<void>,\n    modulePostprocessor?: (manifest: TModuleManifest, module: CompiledModule) => Promise<void>\n  ): void {\n    this.manifestProcessors.registerManifestType(type, typeMatcher, modulePreprocessor, modulePostprocessor);\n  }\n\n  isBundleLoaded(bundleName: string): boolean {\n    return !!this.bundlesCache[bundleName];\n  }\n\n  load(filterFn?: (m: TModuleManifest) => boolean): Promise<void> {\n    this.startupCheck();\n\n    return fetch(this.entrypoint.manifestUrl)\n      .then((response: Response) => response.text())\n      .then((bundlesText: string) => JSON.parse(bundlesText))\n      .then(\n        // tslint:disable-next-line\n        (bundlesObj: any) => {\n          const flattener = this.entrypoint.flattener;\n          const loadedBundles = flattener ? flattener(bundlesObj) : bundlesObj;\n\n          if (!filterFn) {\n            this._bundlesList = loadedBundles;\n            return;\n          }\n\n          this._bundlesList = loadedBundles.filter(filterFn);\n        }\n      )\n      .then(() =>\n        this.loadBulkBundles((manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.BLOCK)\n      );\n  }\n\n  // tslint:disable-next-line\n  start(runner: (...args: Array<any>) => any): Promise<void> {\n    // Run and load immediately services in parallel\n    return Promise.resolve()\n      .then(() => runner())\n      .then(() =>\n        this.loadBulkBundles((manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.IMMEDIATELY)\n      );\n  }\n\n  loadBundleByManifest(manifest: TModuleManifest): Promise<CompiledModule | void> {\n    if (this.bundlesCache[manifest.name]) {\n      return Promise.resolve(this.bundlesCache[manifest.name]);\n    }\n\n    if (this.loadersCache[manifest.name]) {\n      return this.loadersCache[manifest.name];\n    }\n\n    const serviceFileUrl = this.urlFormatter(manifest);\n\n    this.loadersCache[manifest.name] = this.manifestProcessors\n      .runPreprocessor(manifest)\n      .then(() => fetchBundleSource(serviceFileUrl))\n      .then((source: string) => compileSource(source, this.dependencies))\n      .then((compiledModule: CompiledModule) => {\n        this.bundlesCache[manifest.name] = compiledModule;\n\n        return this.manifestProcessors\n          .runPostprocessor(manifest, compiledModule)\n          .then(() => compiledModule)\n          .catch(() => {\n            throw new PostprocessorError('Postprocessor crashed');\n          });\n      })\n      .catch((error: NoDependencyError | CompileModuleError | PostprocessorError) => {\n        console.error(`Module: ${manifest.name}. Error: ${error.message}`);\n\n        return void 0;\n      });\n\n    return this.loadersCache[manifest.name];\n  }\n\n  loadBundleByName(name: string): Promise<CompiledModule | void> {\n    const manifest = this._bundlesList.find((m: TModuleManifest) => m.name === name);\n    if (!manifest) {\n      throw new Error(`Module with name \"${name}\" is not declared`);\n    }\n\n    return this.loadBundleByManifest(manifest);\n  }\n}\n"],"names":["ModuleLoadStrategy","tslib_1.__extends","Error","this","ManifestProcessors","manifest","_a","Object","keys","typeMatchers","_i","typeKey","typeMatcher","console","warn","name","type","modulePreprocessor","modulePostprocessor","modulePreprocessors","modulePostprocessors","getModuleTypeByManifest","Promise","resolve","module","InvalidHttpStatusStart","fetchBundleSource","url","fetch","then","response","status","LoadBundleError","text","compileSource","source","dependencies","exports","eval","ex","CompileModuleError","message","ModuleLoaderTool","_bundlesList","urlFormatter","entrypoint","filterFn","all","bundlesList","filter","map","_this","loadBundleByManifest","compiledBundles","forEach","compiledBundle","controls","start","formatter","manifestProcessors","registerManifestType","bundleName","bundlesCache","startupCheck","manifestUrl","bundlesText","JSON","parse","bundlesObj","flattener","loadedBundles","loadBulkBundles","loadStrategy","BLOCK","runner","IMMEDIATELY","loadersCache","serviceFileUrl","runPreprocessor","compiledModule","runPostprocessor","catch","PostprocessorError","error","find","m"],"mappings":"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"}
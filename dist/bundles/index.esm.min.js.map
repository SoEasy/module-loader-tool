{"version":3,"file":"index.esm.min.js","sources":["../../src/interface.ts","../../src/errors.ts","../../src/manifest-processors.ts","../../src/module-loader-tool.ts"],"sourcesContent":["export enum ModuleLoadStrategy {\n  BLOCK = 'block',\n  IMMEDIATELY = 'immediately',\n  ON_DEMAND = 'on_demand',\n  LAZY = 'lazy'\n}\n\nexport interface IBaseModuleManifest {\n  name: string;\n  loadStrategy: ModuleLoadStrategy;\n  fileName: string;\n}\n\nexport interface IModuleLoaderEntrypoint<T extends IBaseModuleManifest> {\n  manifestUrl: string;\n  // tslint:disable-next-line\n  flattener?: (manifestObject: any) => Array<T>;\n}\n\nexport type ModuleDependencies = Record<string, object>;\nexport type ModuleUrlFormatter<T extends IBaseModuleManifest> = (manifest: T) => string;\n\nexport type CompiledModuleControls = {\n  start?: () => void;\n  getComponent?: () => React.ComponentClass;\n};\n\nexport type CompiledModule = {\n  exports: {\n    controls: CompiledModuleControls;\n    [key: string]: object;\n  };\n};\n\nexport type TypeMatcher<T> = (manifest: T) => boolean;\nexport type ModulePreprocessor<T> = (manifest: T) => Promise<void>;\nexport type ModulePostprocessor<T> = (manifest: T, module: CompiledModule) => Promise<void>;\n","export class NoDependencyError extends Error {}\n// tslint:disable-next-line\nexport class CompileModuleError extends Error {}\n// tslint:disable-next-line\nexport class CreationModuleError extends Error {}\n// tslint:disable-next-line\nexport class LoadBundleError extends Error {}\n// tslint:disable-next-line\nexport class PostprocessorError extends Error {}\n","import { CompiledModule, IBaseModuleManifest, ModulePostprocessor, ModulePreprocessor, TypeMatcher } from './interface';\n\nexport class ManifestProcessors<TModuleManifest extends IBaseModuleManifest> {\n  private typeMatchers: Record<string, TypeMatcher<TModuleManifest>> = {};\n  private modulePreprocessors: Record<string, ModulePreprocessor<TModuleManifest>> = {};\n  private modulePostprocessors: Record<string, ModulePostprocessor<TModuleManifest>> = {};\n\n  private getModuleTypeByManifest(manifest: TModuleManifest): string | void {\n    for (const typeKey of Object.keys(this.typeMatchers)) {\n      const typeMatcher = this.typeMatchers[typeKey];\n      if (typeMatcher(manifest)) {\n        return typeKey;\n      }\n    }\n    console.warn(`Cant resolve type of service \"${manifest.name}\"`);\n    return;\n  }\n\n  registerManifestType(\n    type: string,\n    typeMatcher: TypeMatcher<TModuleManifest>,\n    modulePreprocessor?: ModulePreprocessor<TModuleManifest>,\n    modulePostprocessor?: ModulePostprocessor<TModuleManifest>\n  ): void {\n    this.typeMatchers[type] = typeMatcher;\n    if (modulePreprocessor) {\n      this.modulePreprocessors[type] = modulePreprocessor;\n    }\n    if (modulePostprocessor) {\n      this.modulePostprocessors[type] = modulePostprocessor;\n    }\n  }\n\n  runPreprocessor(manifest: TModuleManifest): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePreprocessors[type] ? this.modulePreprocessors[type](manifest) : Promise.resolve();\n  }\n\n  runPostprocessor(manifest: TModuleManifest, module: CompiledModule): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePostprocessors[type] ? this.modulePostprocessors[type](manifest, module) : Promise.resolve();\n  }\n}\n","import { CompileModuleError, LoadBundleError, NoDependencyError, PostprocessorError } from './errors';\nimport {\n  CompiledModule,\n  IBaseModuleManifest,\n  IModuleLoaderEntrypoint,\n  ModuleDependencies,\n  ModuleLoadStrategy,\n  ModuleUrlFormatter\n} from './interface';\nimport { ManifestProcessors } from './manifest-processors';\n\nconst InvalidHttpStatusStart = 400;\n\nfunction fetchBundleSource(url: string): Promise<string> {\n  return fetch(url).then((response: Response) => {\n    if (response.status >= InvalidHttpStatusStart) {\n      throw new LoadBundleError(`Cant load bundle, http error ${response.status}`);\n    }\n\n    return response.text();\n  });\n}\n\nfunction compileSource(source: string, dependencies: ModuleDependencies): CompiledModule {\n  // @ts-ignore\n  // tslint:disable-next-line\n  const require = (name: string): any => {\n    const dependency = dependencies[name];\n    if (!dependency) {\n      // В любом случае кинуть ошибку. Может быть конечно, что микросервис просит зависимость,\n      // но не использует её и скомпилируется, однако лучше явно сообщить и по результатам:\n      // а) Выпилить зависимость из микросервиса\n      // б) Внести зависимость в ядро\n      // в) Вкомпилировать зависимость в микросервис\n      throw new NoDependencyError(`Dependency \"${name}\" does not provided by core application`);\n    }\n\n    return dependency;\n  };\n  const exports = {};\n  const module = {\n    exports: {}\n  };\n  try {\n    // tslint:disable-next-line\n    eval(source);\n  } catch (ex) {\n    throw new CompileModuleError(`Cant compile module: ${ex.message}`);\n  }\n\n  return module as CompiledModule;\n}\n\nexport class ModuleLoaderTool<TModuleManifest extends IBaseModuleManifest> {\n  private dependencies: ModuleDependencies = {};\n  private urlFormatter: ModuleUrlFormatter<TModuleManifest>;\n  private entrypoint: IModuleLoaderEntrypoint<TModuleManifest>;\n\n  private manifestProcessors: ManifestProcessors<TModuleManifest> = new ManifestProcessors();\n  private _bundlesList: Array<TModuleManifest>;\n  private bundlesCache: Record<string, CompiledModule> = {};\n  private loadersCache: Record<string, Promise<CompiledModule | void>> = {};\n\n  get bundlesList(): Array<TModuleManifest> {\n    return this._bundlesList;\n  }\n\n  private startupCheck(): void {\n    if (!this.urlFormatter) {\n      throw new Error('urlFormatter is not defined');\n    }\n\n    if (!this.entrypoint) {\n      throw new Error('entrypoint is not defined');\n    }\n  }\n\n  private loadBulkBundles(filterFn: (manifest: TModuleManifest) => boolean): Promise<void> {\n    return Promise.all(\n      this.bundlesList.filter(filterFn).map((manifest: TModuleManifest) => this.loadBundleByManifest(manifest))\n    ).then((compiledBundles: Array<CompiledModule | void>) => {\n      compiledBundles.forEach((compiledBundle: CompiledModule | void) => {\n        const controls = compiledBundle && compiledBundle.exports.controls;\n        if (controls && controls.start) {\n          controls.start();\n        }\n      });\n    });\n  }\n\n  defineDependencies(dependencies: ModuleDependencies): void {\n    this.dependencies = dependencies;\n  }\n\n  defineUrlFormatter(formatter: ModuleUrlFormatter<TModuleManifest>): void {\n    this.urlFormatter = formatter;\n  }\n\n  defineEntrypoint(entrypoint: IModuleLoaderEntrypoint<TModuleManifest>): void {\n    this.entrypoint = entrypoint;\n  }\n\n  defineManifestType(\n    type: string,\n    typeMatcher: (manifest: TModuleManifest) => boolean,\n    modulePreprocessor?: (manifest: TModuleManifest) => Promise<void>,\n    modulePostprocessor?: (manifest: TModuleManifest, module: CompiledModule) => Promise<void>\n  ): void {\n    this.manifestProcessors.registerManifestType(type, typeMatcher, modulePreprocessor, modulePostprocessor);\n  }\n\n  isBundleLoaded(bundleName: string): boolean {\n    return !!this.bundlesCache[bundleName];\n  }\n\n  load(filterFn?: (m: TModuleManifest) => boolean): Promise<void> {\n    this.startupCheck();\n\n    return fetch(this.entrypoint.manifestUrl)\n      .then((response: Response) => response.text())\n      .then((bundlesText: string) => JSON.parse(bundlesText))\n      .then(\n        // tslint:disable-next-line\n        (bundlesObj: any) => {\n          const flattener = this.entrypoint.flattener;\n          const loadedBundles = flattener ? flattener(bundlesObj) : bundlesObj;\n\n          if (!filterFn) {\n            this._bundlesList = loadedBundles;\n            return;\n          }\n\n          this._bundlesList = loadedBundles.filter(filterFn);\n        }\n      )\n      .then(() =>\n        this.loadBulkBundles((manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.BLOCK)\n      );\n  }\n\n  // tslint:disable-next-line\n  start(runner: (...args: Array<any>) => any): Promise<void> {\n    // Run and load immediately services in parallel\n    return Promise.resolve()\n      .then(() => runner())\n      .then(() =>\n        this.loadBulkBundles((manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.IMMEDIATELY)\n      );\n  }\n\n  loadBundleByManifest(manifest: TModuleManifest): Promise<CompiledModule | void> {\n    if (this.bundlesCache[manifest.name]) {\n      return Promise.resolve(this.bundlesCache[manifest.name]);\n    }\n\n    if (this.loadersCache[manifest.name]) {\n      return this.loadersCache[manifest.name];\n    }\n\n    const serviceFileUrl = this.urlFormatter(manifest);\n\n    this.loadersCache[manifest.name] = this.manifestProcessors\n      .runPreprocessor(manifest)\n      .then(() => fetchBundleSource(serviceFileUrl))\n      .then((source: string) => compileSource(source, this.dependencies))\n      .then((compiledModule: CompiledModule) => {\n        this.bundlesCache[manifest.name] = compiledModule;\n\n        return this.manifestProcessors\n          .runPostprocessor(manifest, compiledModule)\n          .then(() => compiledModule)\n          .catch(() => {\n            throw new PostprocessorError('Postprocessor crashed');\n          });\n      })\n      .catch((error: NoDependencyError | CompileModuleError | PostprocessorError) => {\n        console.error(`Module: ${manifest.name}. Error: ${error.message}`);\n\n        return void 0;\n      });\n\n    return this.loadersCache[manifest.name];\n  }\n\n  loadBundleByName(name: string): Promise<CompiledModule | void> {\n    const manifest = this._bundlesList.find((m: TModuleManifest) => m.name === name);\n    if (!manifest) {\n      throw new Error(`Module with name \"${name}\" is not declared`);\n    }\n\n    return this.loadBundleByManifest(manifest);\n  }\n}\n"],"names":["ModuleLoadStrategy","CompileModuleError","Error","LoadBundleError","PostprocessorError","ManifestProcessors","[object Object]","this","manifest","typeKey","Object","keys","typeMatchers","typeMatcher","console","warn","name","type","modulePreprocessor","modulePostprocessor","modulePreprocessors","modulePostprocessors","getModuleTypeByManifest","Promise","resolve","module","InvalidHttpStatusStart","fetchBundleSource","url","fetch","then","response","status","text","compileSource","source","dependencies","exports","eval","ex","message","ModuleLoaderTool","bundlesList","_bundlesList","urlFormatter","entrypoint","filterFn","all","filter","map","loadBundleByManifest","compiledBundles","forEach","compiledBundle","controls","start","formatter","manifestProcessors","registerManifestType","bundleName","bundlesCache","startupCheck","manifestUrl","bundlesText","JSON","parse","bundlesObj","flattener","loadedBundles","loadBulkBundles","loadStrategy","BLOCK","runner","IMMEDIATELY","loadersCache","serviceFileUrl","runPreprocessor","compiledModule","runPostprocessor","catch","error","find","m"],"mappings":"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"}
{"version":3,"file":"index.esm.min.js","sources":["../../src/interface.ts","../../src/errors.ts","../../src/manifest-processors.ts","../../src/module-loader-tool.ts"],"sourcesContent":["export enum ModuleLoadStrategy {\n  BLOCK = 'block',\n  IMMEDIATELY = 'immediately',\n  ON_DEMAND = 'on_demand',\n  LAZY = 'lazy'\n}\n\nexport interface IBaseModuleManifest {\n  name: string;\n  loadStrategy: ModuleLoadStrategy;\n  fileName: string;\n}\n\nexport interface IModuleLoaderEntrypoint<T extends IBaseModuleManifest> {\n  manifestUrl: string;\n  // tslint:disable-next-line\n  flattener?: (manifestObject: any) => Array<T>;\n}\n\nexport type ModuleDependencies = Record<string, object>;\nexport type ModuleUrlFormatter<T extends IBaseModuleManifest> = (manifest: T) => string;\n\nexport type CompiledModuleControls = {\n  start?: () => void;\n  getComponent?: () => React.ComponentClass\n};\n\nexport type CompiledModule = {\n  exports: {\n    controls: CompiledModuleControls,\n    [key: string]: object\n  }\n};\n\nexport type TypeMatcher<T> = (manifest: T) => boolean;\nexport type ModulePreprocessor<T> = (manifest: T) => Promise<void>;\nexport type ModulePostprocessor<T> = (manifest: T, module: CompiledModule) => Promise<void>;","export class NoDependencyError extends Error {}\n// tslint:disable-next-line\nexport class CompileModuleError extends Error {}\n// tslint:disable-next-line\nexport class CreationModuleError extends Error {}\n// tslint:disable-next-line\nexport class LoadBundleError extends Error {}\n// tslint:disable-next-line\nexport class PostprocessorError extends Error {}\n","import {\n  CompiledModule,\n  IBaseModuleManifest,\n  TypeMatcher,\n  ModulePreprocessor,\n  ModulePostprocessor\n} from './interface';\n\nexport class ManifestProcessors<TModuleManifest extends IBaseModuleManifest> {\n  private typeMatchers: Record<string, TypeMatcher<TModuleManifest>> = {};\n  private modulePreprocessors: Record<string, ModulePreprocessor<TModuleManifest>> = {};\n  private modulePostprocessors: Record<string, ModulePostprocessor<TModuleManifest>> = {};\n\n  private getModuleTypeByManifest(manifest: TModuleManifest): string | void {\n    for (const typeKey of Object.keys(this.typeMatchers)) {\n      const typeMatcher = this.typeMatchers[typeKey];\n      if (typeMatcher(manifest)) {\n        return typeKey;\n      }\n    }\n    console.warn(`Cant resolve type of service \"${manifest.name}\"`);\n    return;\n  }\n\n  registerManifestType(\n    type: string,\n    typeMatcher: TypeMatcher<TModuleManifest>,\n    modulePreprocessor?: ModulePreprocessor<TModuleManifest>,\n    modulePostprocessor?: ModulePostprocessor<TModuleManifest>\n  ): void {\n    this.typeMatchers[type] = typeMatcher;\n    if (modulePreprocessor) { this.modulePreprocessors[type] = modulePreprocessor; }\n    if (modulePostprocessor) { this.modulePostprocessors[type] = modulePostprocessor; }\n  }\n\n  runPreprocessor(manifest: TModuleManifest): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePreprocessors[type] ? this.modulePreprocessors[type](manifest) : Promise.resolve();\n  }\n\n  runPostprocessor(manifest: TModuleManifest, module: CompiledModule): Promise<void> {\n    const type = this.getModuleTypeByManifest(manifest);\n    if (!type) {\n      return Promise.resolve();\n    }\n\n    return this.modulePostprocessors[type] ? this.modulePostprocessors[type](manifest, module) : Promise.resolve();\n  }\n}\n","import {\n  CompileModuleError, LoadBundleError,\n  NoDependencyError,\n  PostprocessorError\n} from './errors';\nimport {\n  CompiledModule,\n  IBaseModuleManifest,\n  IModuleLoaderEntrypoint,\n  ModuleDependencies,\n  ModuleLoadStrategy,\n  ModuleUrlFormatter\n} from './interface';\nimport { ManifestProcessors } from './manifest-processors';\n\nconst InvalidHttpStatusStart = 400;\n\nfunction fetchBundleSource(url: string): Promise<string> {\n  return fetch(url).then((response: Response) => {\n    if (response.status >= InvalidHttpStatusStart) {\n      throw new LoadBundleError(`Cant load bundle, http error ${response.status}`);\n    }\n\n    return response.text();\n  });\n}\n\nfunction compileSource(source: string, dependencies: ModuleDependencies): CompiledModule {\n  // @ts-ignore\n  // tslint:disable-next-line\n  const require = (name: string): any => {\n    const dependency = dependencies[name];\n    if (!dependency) {\n      // В любом случае кинуть ошибку. Может быть конечно, что микросервис просит зависимость,\n      // но не использует её и скомпилируется, однако лучше явно сообщить и по результатам:\n      // а) Выпилить зависимость из микросервиса\n      // б) Внести зависимость в ядро\n      // в) Вкомпилировать зависимость в микросервис\n      throw new NoDependencyError(`Dependency \"${name}\" does not provided by core application`);\n    }\n    return dependency;\n  };\n\n  const module = {\n    exports: {}\n  };\n  try {\n    // tslint:disable-next-line\n    eval(source);\n  } catch (ex) {\n    throw new CompileModuleError(`Cant compile module: ${ex.message}`);\n  }\n\n  return module as CompiledModule;\n}\n\nexport class ModuleLoaderTool<TModuleManifest extends IBaseModuleManifest> {\n  private dependencies: ModuleDependencies = {};\n  private urlFormatter: ModuleUrlFormatter<TModuleManifest>;\n  private entrypoint: IModuleLoaderEntrypoint<TModuleManifest>;\n\n  private manifestProcessors: ManifestProcessors<TModuleManifest> = new ManifestProcessors();\n  private _bundlesList: Array<TModuleManifest>;\n  private bundlesCache: Record<string, CompiledModule> = {};\n  private loadersCache: Record<string, Promise<CompiledModule | void>> = {};\n\n  get bundlesList(): Array<TModuleManifest> {\n    return this._bundlesList;\n  }\n\n  private startupCheck(): void {\n    if (!this.urlFormatter) {\n      throw new Error('urlFormatter is not defined');\n    }\n\n    if (!this.entrypoint) {\n      throw new Error('entrypoint is not defined');\n    }\n  }\n\n  private loadBulkBundles(filterFn: (manifest: TModuleManifest) => boolean): Promise<void> {\n    return Promise.all(\n      this.bundlesList.filter(\n        filterFn\n      ).map(\n        (manifest: TModuleManifest) => this.loadBundleByManifest(manifest)\n      )\n    ).then(\n      (compiledBundles: Array<CompiledModule | void>) => {\n        compiledBundles.forEach((compiledBundle: CompiledModule | void) => {\n          const controls = compiledBundle && compiledBundle.exports.controls;\n          if (controls && controls.start) {\n            controls.start();\n          }\n        });\n      }\n    );\n  }\n\n  defineDependencies(dependencies: ModuleDependencies): void {\n    this.dependencies = dependencies;\n  }\n\n  defineUrlFormatter(formatter: ModuleUrlFormatter<TModuleManifest>): void {\n    this.urlFormatter = formatter;\n  }\n\n  defineEntrypoint(entrypoint: IModuleLoaderEntrypoint<TModuleManifest>): void {\n    this.entrypoint = entrypoint;\n  }\n\n  defineManifestType(\n    type: string,\n    typeMatcher: (manifest: TModuleManifest) => boolean,\n    modulePreprocessor?: (manifest: TModuleManifest) => Promise<void>,\n    modulePostprocessor?: (manifest: TModuleManifest, module: CompiledModule) => Promise<void>\n  ): void {\n    this.manifestProcessors.registerManifestType(\n      type,\n      typeMatcher,\n      modulePreprocessor,\n      modulePostprocessor\n    );\n  }\n\n  isBundleLoaded(bundleName: string): boolean {\n    return !!this.bundlesCache[bundleName];\n  }\n\n  load(filterFn?: (m: TModuleManifest) => boolean): Promise<void> {\n    this.startupCheck();\n\n    return fetch(this.entrypoint.manifestUrl).then(\n      (response: Response) => response.text()\n    ).then(\n      (bundlesText: string) => JSON.parse(bundlesText)\n    ).then(\n      // tslint:disable-next-line\n      (bundlesObj: any) => {\n        const flattener = this.entrypoint.flattener;\n        const loadedBundles = flattener ? flattener(bundlesObj) : bundlesObj;\n\n        if (!filterFn) {\n          this._bundlesList = loadedBundles;\n          return;\n        }\n\n        this._bundlesList = loadedBundles.filter(filterFn);\n      }\n    ).then(\n      () => this.loadBulkBundles((manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.BLOCK)\n    );\n  }\n\n  // tslint:disable-next-line\n  start(runner: (...args: Array<any>) => any): Promise<void> {\n    // Run and load immediately services in parallel\n    return Promise.resolve().then(\n      () => runner()\n    ).then(\n      () => this.loadBulkBundles(\n        (manifest: TModuleManifest) => manifest.loadStrategy === ModuleLoadStrategy.IMMEDIATELY\n      )\n    );\n  }\n\n  loadBundleByManifest(manifest: TModuleManifest): Promise<CompiledModule | void> {\n    if (this.bundlesCache[manifest.name]) {\n      return Promise.resolve(this.bundlesCache[manifest.name]);\n    }\n\n    if (this.loadersCache[manifest.name]) {\n      return this.loadersCache[manifest.name];\n    }\n\n    const serviceFileUrl = this.urlFormatter(manifest);\n\n    this.loadersCache[manifest.name] = this.manifestProcessors.runPreprocessor(manifest).then(\n      () => fetchBundleSource(serviceFileUrl)\n    ).then(\n      (source: string) => compileSource(source, this.dependencies)\n    ).then(\n      (compiledModule: CompiledModule) => {\n        this.bundlesCache[manifest.name] = compiledModule;\n\n        return this.manifestProcessors.runPostprocessor(manifest, compiledModule).then(\n          () => compiledModule\n        ).catch(\n          () => {\n            throw new PostprocessorError('Postprocessor crashed');\n          }\n        );\n      }\n    ).catch(\n      (error: NoDependencyError | CompileModuleError | PostprocessorError) => {\n        console.error(`Module: ${manifest.name}. Error: ${error.message}`);\n\n        return void 0;\n      }\n    );\n\n    return this.loadersCache[manifest.name];\n  }\n\n  loadBundleByName(name: string): Promise<CompiledModule | void> {\n    const manifest = this._bundlesList.find(\n      (m: TModuleManifest) => m.name === name\n    );\n    if (!manifest) {\n      throw new Error(`Module with name \"${name}\" is not declared`);\n    }\n\n    return this.loadBundleByManifest(manifest);\n  }\n}\n"],"names":["ModuleLoadStrategy","CompileModuleError","Error","LoadBundleError","PostprocessorError","ManifestProcessors","[object Object]","this","manifest","typeKey","Object","keys","typeMatchers","typeMatcher","console","warn","name","type","modulePreprocessor","modulePostprocessor","modulePreprocessors","modulePostprocessors","getModuleTypeByManifest","Promise","resolve","module","InvalidHttpStatusStart","fetchBundleSource","url","fetch","then","response","status","text","compileSource","source","dependencies","exports","eval","ex","message","ModuleLoaderTool","bundlesList","_bundlesList","urlFormatter","entrypoint","filterFn","all","filter","map","loadBundleByManifest","compiledBundles","forEach","compiledBundle","controls","start","formatter","manifestProcessors","registerManifestType","bundleName","bundlesCache","startupCheck","manifestUrl","bundlesText","JSON","parse","bundlesObj","flattener","loadedBundles","loadBulkBundles","loadStrategy","BLOCK","runner","IMMEDIATELY","loadersCache","serviceFileUrl","runPreprocessor","compiledModule","runPostprocessor","catch","error","find","m"],"mappings":"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"}
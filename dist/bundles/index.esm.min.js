var ModuleLoadStrategy;
!(function(e) {
  (e.BLOCK = 'block'), (e.IMMEDIATELY = 'immediately'), (e.ON_DEMAND = 'on_demand'), (e.LAZY = 'lazy');
})(ModuleLoadStrategy || (ModuleLoadStrategy = {}));
class CompileModuleError extends Error {}
class LoadBundleError extends Error {}
class PostprocessorError extends Error {}
class ManifestProcessors {
  constructor() {
    (this.typeMatchers = {}), (this.modulePreprocessors = {}), (this.modulePostprocessors = {});
  }
  getModuleTypeByManifest(e) {
    for (const t of Object.keys(this.typeMatchers)) {
      if ((0, this.typeMatchers[t])(e)) return t;
    }
    console.warn(`Cant resolve type of service "${e.name}"`);
  }
  registerManifestType(e, t, s, r) {
    (this.typeMatchers[e] = t), s && (this.modulePreprocessors[e] = s), r && (this.modulePostprocessors[e] = r);
  }
  runPreprocessor(e) {
    const t = this.getModuleTypeByManifest(e);
    return t && this.modulePreprocessors[t] ? this.modulePreprocessors[t](e) : Promise.resolve();
  }
  runPostprocessor(e, t) {
    const s = this.getModuleTypeByManifest(e);
    return s && this.modulePostprocessors[s] ? this.modulePostprocessors[s](e, t) : Promise.resolve();
  }
}
const InvalidHttpStatusStart = 400;
function fetchBundleSource(e) {
  return fetch(e).then(e => {
    if (e.status >= InvalidHttpStatusStart) throw new LoadBundleError(`Cant load bundle, http error ${e.status}`);
    return e.text();
  });
}
function compileSource(source, dependencies) {
  const module = { exports: {} };
  try {
    eval(source);
  } catch (e) {
    throw new CompileModuleError(`Cant compile module: ${e.message}`);
  }
  return module;
}
class ModuleLoaderTool {
  constructor() {
    (this.dependencies = {}),
      (this.manifestProcessors = new ManifestProcessors()),
      (this.bundlesCache = {}),
      (this.loadersCache = {});
  }
  get bundlesList() {
    return this._bundlesList;
  }
  startupCheck() {
    if (!this.urlFormatter) throw new Error('urlFormatter is not defined');
    if (!this.entrypoint) throw new Error('entrypoint is not defined');
  }
  loadBulkBundles(e) {
    return Promise.all(this.bundlesList.filter(e).map(e => this.loadBundleByManifest(e))).then(e => {
      e.forEach(e => {
        const t = e && e.exports.controls;
        t && t.start && t.start();
      });
    });
  }
  defineDependencies(e) {
    this.dependencies = e;
  }
  defineUrlFormatter(e) {
    this.urlFormatter = e;
  }
  defineEntrypoint(e) {
    this.entrypoint = e;
  }
  defineManifestType(e, t, s, r) {
    this.manifestProcessors.registerManifestType(e, t, s, r);
  }
  isBundleLoaded(e) {
    return !!this.bundlesCache[e];
  }
  load(e) {
    return (
      this.startupCheck(),
      fetch(this.entrypoint.manifestUrl)
        .then(e => e.text())
        .then(e => JSON.parse(e))
        .then(t => {
          const s = this.entrypoint.flattener,
            r = s ? s(t) : t;
          this._bundlesList = e ? r.filter(e) : r;
        })
        .then(() => this.loadBulkBundles(e => e.loadStrategy === ModuleLoadStrategy.BLOCK))
    );
  }
  start(e) {
    return Promise.resolve()
      .then(() => e())
      .then(() => this.loadBulkBundles(e => e.loadStrategy === ModuleLoadStrategy.IMMEDIATELY));
  }
  loadBundleByManifest(e) {
    if (this.bundlesCache[e.name]) return Promise.resolve(this.bundlesCache[e.name]);
    if (this.loadersCache[e.name]) return this.loadersCache[e.name];
    const t = this.urlFormatter(e);
    return (
      (this.loadersCache[e.name] = this.manifestProcessors
        .runPreprocessor(e)
        .then(() => fetchBundleSource(t))
        .then(e => compileSource(e, this.dependencies))
        .then(
          t => (
            (this.bundlesCache[e.name] = t),
            this.manifestProcessors
              .runPostprocessor(e, t)
              .then(() => t)
              .catch(() => {
                throw new PostprocessorError('Postprocessor crashed');
              })
          )
        )
        .catch(t => {
          console.error(`Module: ${e.name}. Error: ${t.message}`);
        })),
      this.loadersCache[e.name]
    );
  }
  loadBundleByName(e) {
    const t = this._bundlesList.find(t => t.name === e);
    if (!t) throw new Error(`Module with name "${e}" is not declared`);
    return this.loadBundleByManifest(t);
  }
}
export { ModuleLoadStrategy, ModuleLoaderTool };
//# sourceMappingURL=index.esm.min.js.map

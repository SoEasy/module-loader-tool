!(function(e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports, require('tslib'))
    : 'function' == typeof define && define.amd
    ? define(['exports', 'tslib'], t)
    : t(((e = e || self).ModuleLoaderTool = {}), e.tslib_1);
})(this, function(exports, tslib_1) {
  'use strict';
  var c;
  (c = exports.ModuleLoadStrategy || (exports.ModuleLoadStrategy = {})),
    (c.BLOCK = 'block'),
    (c.IMMEDIATELY = 'immediately'),
    (c.ON_DEMAND = 'on_demand'),
    (c.LAZY = 'lazy');
  var NoDependencyError = (function(e) {
      function t() {
        return (null !== e && e.apply(this, arguments)) || this;
      }
      return tslib_1.__extends(t, e), t;
    })(Error),
    CompileModuleError = (function(e) {
      function t() {
        return (null !== e && e.apply(this, arguments)) || this;
      }
      return tslib_1.__extends(t, e), t;
    })(Error),
    CreationModuleError = (function(e) {
      function t() {
        return (null !== e && e.apply(this, arguments)) || this;
      }
      return tslib_1.__extends(t, e), t;
    })(Error),
    LoadBundleError = (function(e) {
      function t() {
        return (null !== e && e.apply(this, arguments)) || this;
      }
      return tslib_1.__extends(t, e), t;
    })(Error),
    PostprocessorError = (function(e) {
      function t() {
        return (null !== e && e.apply(this, arguments)) || this;
      }
      return tslib_1.__extends(t, e), t;
    })(Error),
    ManifestProcessors = (function() {
      function e() {
        (this.typeMatchers = {}), (this.modulePreprocessors = {}), (this.modulePostprocessors = {});
      }
      return (
        (e.prototype.getModuleTypeByManifest = function(e) {
          for (var t = 0, r = Object.keys(this.typeMatchers); t < r.length; t++) {
            var o = r[t];
            if ((0, this.typeMatchers[o])(e)) return o;
          }
          console.warn('Cant resolve type of service "' + e.name + '"');
        }),
        (e.prototype.registerManifestType = function(e, t, r, o) {
          (this.typeMatchers[e] = t), r && (this.modulePreprocessors[e] = r), o && (this.modulePostprocessors[e] = o);
        }),
        (e.prototype.runPreprocessor = function(e) {
          var t = this.getModuleTypeByManifest(e);
          return t && this.modulePreprocessors[t] ? this.modulePreprocessors[t](e) : Promise.resolve();
        }),
        (e.prototype.runPostprocessor = function(e, t) {
          var r = this.getModuleTypeByManifest(e);
          return r && this.modulePostprocessors[r] ? this.modulePostprocessors[r](e, t) : Promise.resolve();
        }),
        e
      );
    })(),
    InvalidHttpStatusStart = 400;
  function fetchBundleSource(e) {
    return fetch(e).then(function(e) {
      if (e.status >= InvalidHttpStatusStart) throw new LoadBundleError('Cant load bundle, http error ' + e.status);
      return e.text();
    });
  }
  function compileSource(source, dependencies) {
    var module = { exports: {} };
    try {
      eval(source);
    } catch (e) {
      throw new CompileModuleError('Cant compile module: ' + e.message);
    }
    return module;
  }
  var ModuleLoaderTool = (function() {
    function e() {
      (this.dependencies = {}),
        (this.manifestProcessors = new ManifestProcessors()),
        (this.bundlesCache = {}),
        (this.loadersCache = {});
    }
    return (
      Object.defineProperty(e.prototype, 'bundlesList', {
        get: function() {
          return this._bundlesList;
        },
        enumerable: !0,
        configurable: !0
      }),
      (e.prototype.startupCheck = function() {
        if (!this.urlFormatter) throw new Error('urlFormatter is not defined');
        if (!this.entrypoint) throw new Error('entrypoint is not defined');
      }),
      (e.prototype.loadBulkBundles = function(e) {
        var t = this;
        return Promise.all(
          this.bundlesList.filter(e).map(function(e) {
            return t.loadBundleByManifest(e);
          })
        ).then(function(e) {
          e.forEach(function(e) {
            var t = e && e.exports.controls;
            t && t.start && t.start();
          });
        });
      }),
      (e.prototype.defineDependencies = function(e) {
        this.dependencies = e;
      }),
      (e.prototype.defineUrlFormatter = function(e) {
        this.urlFormatter = e;
      }),
      (e.prototype.defineEntrypoint = function(e) {
        this.entrypoint = e;
      }),
      (e.prototype.defineManifestType = function(e, t, r, o) {
        this.manifestProcessors.registerManifestType(e, t, r, o);
      }),
      (e.prototype.isBundleLoaded = function(e) {
        return !!this.bundlesCache[e];
      }),
      (e.prototype.load = function(o) {
        var n = this;
        return (
          this.startupCheck(),
          fetch(this.entrypoint.manifestUrl)
            .then(function(e) {
              return e.text();
            })
            .then(function(e) {
              return JSON.parse(e);
            })
            .then(function(e) {
              var t = n.entrypoint.flattener,
                r = t ? t(e) : e;
              n._bundlesList = o ? r.filter(o) : r;
            })
            .then(function() {
              return n.loadBulkBundles(function(e) {
                return e.loadStrategy === exports.ModuleLoadStrategy.BLOCK;
              });
            })
        );
      }),
      (e.prototype.start = function(e) {
        var t = this;
        return Promise.resolve()
          .then(function() {
            return e();
          })
          .then(function() {
            return t.loadBulkBundles(function(e) {
              return e.loadStrategy === exports.ModuleLoadStrategy.IMMEDIATELY;
            });
          });
      }),
      (e.prototype.loadBundleByManifest = function(t) {
        var r = this;
        if (this.bundlesCache[t.name]) return Promise.resolve(this.bundlesCache[t.name]);
        if (this.loadersCache[t.name]) return this.loadersCache[t.name];
        var e = this.urlFormatter(t);
        return (
          (this.loadersCache[t.name] = this.manifestProcessors
            .runPreprocessor(t)
            .then(function() {
              return fetchBundleSource(e);
            })
            .then(function(e) {
              return compileSource(e, r.dependencies);
            })
            .then(function(e) {
              return (
                (r.bundlesCache[t.name] = e),
                r.manifestProcessors
                  .runPostprocessor(t, e)
                  .then(function() {
                    return e;
                  })
                  .catch(function() {
                    throw new PostprocessorError('Postprocessor crashed');
                  })
              );
            })
            .catch(function(e) {
              console.error('Module: ' + t.name + '. Error: ' + e.message);
            })),
          this.loadersCache[t.name]
        );
      }),
      (e.prototype.loadBundleByName = function(t) {
        var e = this._bundlesList.find(function(e) {
          return e.name === t;
        });
        if (!e) throw new Error('Module with name "' + t + '" is not declared');
        return this.loadBundleByManifest(e);
      }),
      e
    );
  })();
  (exports.ModuleLoaderTool = ModuleLoaderTool), Object.defineProperty(exports, '__esModule', { value: !0 });
});
//# sourceMappingURL=index.umd.min.js.map
